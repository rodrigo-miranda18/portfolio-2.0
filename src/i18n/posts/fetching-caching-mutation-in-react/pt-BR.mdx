export const metadata = {
  title: 'Fetch de dados, cache, e muta√ß√£o no React',
  description: 'Entenda as melhores op√ß√µes para manipula√ß√£o de dados em uma aplica√ß√£o React',
  publishedDate: '2025-01-11T10:19:00Z',
	timeToRead: '10min de leitura',
	heroImage: '/posts/fetching-caching-mutation-in-react.png',
  tags: ['html', 'css', 'javascript', 'js', 'react', 'next.js', 'swr', 'react-query', 'server-components', 'hooks'],
}

O principal objetivo desse artigo √© discutir as melhores op√ß√µes para lidar com dados em uma aplica√ß√£o React moderna.

Qualquer aplica√ß√£o web um pouco mais complexa precisa lidar com fetch e muta√ß√£o de dados, √© uma tarefa fundamental em quase todo projeto. Entretanto, com as √∫ltimas atualiza√ß√µes e constantes evolu√ß√µes no ecossistema React, novas maneiras de lidar com dados foram introduzidas, e o principal objetivo desse artigo √© apresentar as principais formas e discutir as melhores.

## Fetch de dados

O fetch de dados no React pode ser realizado de diferentes formas, dependendo do local onde ele ocorre: no **server-side** ou no **client-side**. Abaixo vamos discutir as op√ß√µes de cada uma.

### Server-side

Com a introdu√ß√£o dos Server Components, se tornou poss√≠vel realizar chamadas ass√≠ncronas dentro de componentes React. Com isso podemos fazer fetch de dados diretamente nos nossos componentes. Uma das possibilidades √© utilizar o m√©todo nativo **fetch**:

```jsx
export default async function Page() {
  const response = await fetch("https://api.example.com/data");
  const data = await data.json();

  return (
    <pre>{JSON.stringify(data)}</pre>
  );
}
```

Se voc√™ estiver utilizando um framework como o Next.js, pode utilizar as estrat√©gias de cache fornecidas pela biblioteca. O Next.js extende a [fetch](https://developer.mozilla.org/docs/Web/API/Fetch_API) api nativa do browser, adicionando uma nova sem√¢ntica para defini√ß√£o de cache e revalida√ß√£o.

```jsx
fetch(`https://...`, {
  cache: 'force-cache' | 'no-store',
  next: { revalidate: false | 0 | number }
})
```

As op√ß√µes de cache e revalida√ß√£o permitem que voc√™ controle o comportamento do cache de forma mais granular, definindo se a requisi√ß√£o deve ser feita novamente ou n√£o, e em qual intervalo de tempo.

Por padr√£o, a partir da vers√£o 15 do Next.js, a diretiva padr√£o de cache √© o `no-store`, o que significa que a requisi√ß√£o n√£o ser√° cacheada e executar√° a cada renderiza√ß√£o. A diretiva `no-store` √© √∫til para casos em que voc√™ precisa de dados sempre atualizados, como em um dashboard, por exemplo.

No entanto, na maioria das vezes n√£o √© necess√°rio e nem desej√°vel que a requisi√ß√£o seja feita a todo momento. Para esses casos, voc√™ pode utilizar a diretiva `force-cache` para que a requisi√ß√£o seja cacheada e definir um tempo de vida para o cache com a op√ß√£o `revalidate`. O valor deve ser definido em segundos.

```jsx
fetch(`https://...`, {
  cache: 'force-cache',
  next: { revalidate: 60 } // Tempo de vida do cache de 60 segundos
})

fetch(`https://...`, {
  cache: 'no-store',
  next: { revalidate: 60 } // Dispara um erro pois as op√ß√µes s√£o conflitantes
})
```

Tamb√©m √© poss√≠vel taggear as requisi√ß√µes com o par√¢metro `tags`.

```jsx
{ cache: 'force-cache', next: { tags: ['posts'] } }
```

Este recurso √© √∫til para casos em que voc√™ precisa ter um controle maior do cache das requisi√ß√µes e tamb√©m invalidar manualmente utilizando o m√©todo [revalidateTag](https://nextjs.org/docs/app/api-reference/functions/revalidateTag). Vamos explorar melhor esse m√©todo ao falarmos de muta√ß√£o de dados.

### Client-side

No client-side, a forma mais utilizada e mais comum de fazer fetch de dados √© utilizando o hook `useEffect` para realizar a chamada ass√≠ncrona. O exemplo mais b√°sico disso √©:

```jsx
'use client';

import { useEffect, useState } from 'react';

export default function Dashboard() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch("https://api.example.com/data")
      .then((response) => response.json())
      .then((data) => setData(data));
  }, []);

  if (!data) {
    return <div>loading...</div>;
  }

  return (
    <pre>{JSON.stringify(data)}</pre>
  );
}
```

No entanto, mesmo sendo a forma mais utilizada, **n√£o quer dizer que √© a melhor.**

A partir da vers√£o 19 do React, foi introduzido uma nova API para lidar com promises ou contextos, o `use`. O `use` pode ser utilizado para resolver promises de forma mais declarativa e sem a necessidade de utilizar o hook `useEffect`. O exemplo acima poderia ser reescrito da seguinte forma:

```jsx
'use client';

import { use } from 'react';

export default function Dashboard({ promise }) {
  const data = use(promise);

  return (
    <pre>{JSON.stringify(data)}</pre>
  );
}
```

Como deu para notar, a promise √© passada como prop para o componente `Dashboard`. Isso se d√° pois o `use` n√£o √© capaz de resolver promises criadas na renderiza√ß√£o, portanto, elas devem ser criadas em um server component e passadas como props para client components.

A API `use` integra com o [Suspense](https://react.dev/reference/react/Suspense) e com [Error Boundaries](https://react.dev/reference/react/Suspense). Enquanto a Promise n√£o √© resolvida, o componente fornecido como fallback do Suspense ser√° exibido em tela. Caso a promise seja rejeitada, o erro ser√° capturado pelo Error Boundary mais pr√≥ximo. Quando enfim a promise for resolvida com sucesso, ent√£o o componente `Dashboard` √© renderizado.

√â importante utilizar o Suspense juntamente com o `use` pois o `use` suspende a renderiza√ß√£o do componente at√© que a promise seja resolvida. Ao utilizar o Suspense voc√™ exibe um feedback ao usu√°rio enquanto o componente `Dashboard` n√£o √© renderizado.

O exemplo completo ficaria assim:

```jsx
// page.js
import { DashboardContainer } from './Dashboard';

async function getData() {
  const response = await fetch('https://dummyjson.com/products');
  return response.json();
}

export default function Home() {
  const promise = getData();

  return (
    <DashboardContainer promise={promise} />
  );
}

// Dashboard.js
'use client';

import { Suspense, use } from 'react';
import { ErrorBoundary } from "react-error-boundary";

export function Dashboard({ promise }) {
  const data = use(promise);

  return (
    <pre>{JSON.stringify(data)}</pre>
  );
}

export function DashboardContainer({ promise }) {
  return (
    <ErrorBoundary fallback={<p>‚ö†Ô∏èSomething went wrong</p>}>
      <Suspense fallback={<p>‚åõLoading...</p>}>
        <Dashboard promise={promise} />
      </Suspense>
    </ErrorBoundary>
  );
}
```

Para evitar ficar passando a promise como prop para v√°rios componentes filhos e evitar "prop drilling", um bom padr√£o a ser utilizado √© combinar o `use` com a `Context API`. Voc√™ pode definir um context que envolve partes de sua aplica√ß√£o e ent√£o encaminhar a promise para o provider do contexto.

```jsx
import React, { createContext, useContext } from 'react';

const ProductsContext = createContext(null);

export function ProductsProvider({ children }) {
  let promise = fetch('https://dummyjson.com/products').then(res => res.json());

  return (
    <ProductsContext.Provider value={{ promise }}>
      {children}
    </ProductsContext.Provider>
  );
}

export function useProductsContext() {
  let context = useContext(ProductsContext)

  if (!context) {
    throw new Error('useProductsContext must be used within a ProductsProvider')
  }
  return context
}
```

E ent√£o voc√™ pode "consumir" o contexto em qualquer componente filho do `ProductsProvider`:

```jsx
'use client'

import { use } from 'react';
import { useProductsContext } from 'app/context';

export function Dashboard() {
  let { promise } = useProductsContext()
  let products = use(promise)

  return (
    <ul>
      {products.map((product) => (
        <li key={product.id}>{product.title}</li>
      ))}
    </ul>
  )
}
```

Isso √© uma √≥tima pr√°tica em casos onde voc√™ possui estados globais e √© necess√°rio encaminh√°-los profundamente na √°rvore de componentes, especialmente quando voc√™ possui muitos client components.

#### Outras alternativas

Podemos utilizar tamb√©m bibliotecas como [**react-query**](https://tanstack.com/query/v5/docs/framework/react/overview) ou [**swr**](https://swr.vercel.app/).

O benef√≠cio de se utilizar essas bibliotecas dedicadas √© que elas j√° possuem funcionalidades prontas para lidar com cache, revalida√ß√£o, e outras funcionalidades mais complexas de uma aplica√ß√£o real. Al√©m disso, elas possuem uma API mais simples e intuitiva para lidar com os estados de loading, erro, etc.

<details className="mt-6">
  <summary className="text-lg cursor-pointer">Exemplo de fetch de dados com **react-query**</summary>

  ```jsx
  // react-query
  'use client';

  import { useQuery } from '@tanstack/react-query';

  async function getData() {
    const response = await fetch('https://dummyjson.com/products');
    return response.json();
  }

  export default function Dashboard() {
    const { data, error, isLoading } = useQuery({
      queryKey: ['data'],
      queryFn: getData,
    });

    if (error) return <div>Failed to load</div>;
    if (isLoading) return <div>Loading...</div>;

    return (
      <pre>{JSON.stringify(data)}</pre>
    );
  }
  ```
</details>

<details className="mt-4">
  <summary className="text-lg cursor-pointer">Exemplo de fetch de dados com **swr**</summary>

  ```jsx
  // swr
  'use client';

  import useSWR from 'swr';

  async function fetcher() {
    const response = await fetch('https://dummyjson.com/products');
    return response.json();
  }

  export function Dashboard() {
    const { data, error, isLoading } = useSWR('/products', fetcher);

    if (error) return <div>Failed to load</div>;
    if (isLoading) return <div>Loading...</div>;

    return (
      <pre>{JSON.stringify(data)}</pre>
    );
  }
  ```
</details>

<hr/>

## Muta√ß√£o de dados

A muta√ß√£o de dados √© o ato de criar, atualizar, ou deletar dados em tempo real na aplica√ß√£o.

Em um exemplo b√°sico podemos pensar em realizar um POST/PATCH/DELETE request, e atualizar o estado da aplica√ß√£o atrav√©s de um estado global com os dados atualizados.

No entanto, essa abordagem pode se tornar complexa e dif√≠cil de manter conforme a aplica√ß√£o cresce. Imagine criar um estado global para cada entidade da aplica√ß√£o, e ter que lidar com a atualiza√ß√£o de cada um deles de forma manual.

Tamb√©m efetuar um full page refresh a cada muta√ß√£o n√£o √© uma experi√™ncia agrad√°vel para o usu√°rio, al√©m de que a cada atualiza√ß√£o √© necess√°rio fazer uma nova requisi√ß√£o para buscar os dados atualizados.

Vamos ver como podemos melhorar essa experi√™ncia utilizando as mesmas bibliotecas que vimos anteriormente.

### Next.js

No Next.js, podemos utilizar as [Server Actions](https://react.dev/reference/rsc/server-functions) para realizar muta√ß√µes de dados no server-side. As Server Actions s√£o fun√ß√µes que s√£o executadas no server-side e podem ser chamadas diretamente nos componentes React.

Em Server Components podemos criar Server Functions com a diretiva `use server` no in√≠cio da fun√ß√£o.

```jsx
export async default function Page() {
  // Server Action
  async function createPost() {
    'use server'
    // Mutate data
    // ...
 
  return <></>;
}
```

J√° em Client Components, n√≥s podemos criar um arquivo separado que possui a diretiva `use server` e chamar essas fun√ß√µes diretamente em eventos html, como um click de um bot√£o, por exemplo, ou utilizando o atributo action do elemento form.

```jsx
// actions.js
'use server';
 
export async function createPost() {}

// button.js
'use client'
 
import { createPost } from '@/app/actions';
 
export function Button() {
  return (
    <button
      onClick={async () => {
        const createdPost = await createPost()
      }}
    >
      Create
    </button>
  );
}
```

Depois de realizado a muta√ß√£o, podemos utilizar o m√©todo `revalidateTag` ou o m√©todo `revalidatePath` para revalidar o cache das requisi√ß√µes.

```jsx
// actions.js
'use server'
 
import { revalidateTag } from 'next/cache';
import { redirect } from 'next/navigation'
 
export async function createPost(formData: FormData) {
  // Mutate data
  // ...
 
  revalidateTag('posts'); // Ou revalidatePath('/posts')
  redirect('/posts'); // Redirecionar para a p√°gina de posts
}
```

### React Query

Para fins de exemplo, vou apresentar apenas a muta√ß√£o de dados com o React Query, mas o mesmo pode ser feito com o SWR de forma parecida.

No React Query, podemos utilizar o hook `useMutation` para realizar muta√ß√µes de dados. O hook `useMutation` retorna uma fun√ß√£o `mutateAsync` que pode ser chamada para realizar a muta√ß√£o.

```jsx
'use client';

import { useMutation, useQueryClient } from '@tanstack/react-query';

async function createPost(formData) {
  const response = await fetch('https://api.example.com/posts', {
    method: 'POST',
    body: JSON.stringify(formData),
  });

  return response.json();
}

export function App() {
  const queryClient = useQueryClient();
  const { mutateAsync: createPostFn } = useMutation({
    mutationFn: createPost,
    onSuccess(_, variables) {
      queryClient.setQueryData(['posts'], (data) => (
        [...data, variables]
      ));
    }
  });

  async function handleCreatePost(data) {
    try {
      await createPostFn(data);

      alert('Post criado com sucesso!');
    } catch (error) {
      alert('Erro ao criar o post');
    }
  }

  return (
    <form onSubmit={handleSubmit(handleCreatePost)}>
      {/* Form fields */}
    </form>
  );
}
```

O hook `useMutation` aceita um objeto de configura√ß√£o com a fun√ß√£o `mutationFn` que √© a fun√ß√£o que realiza a muta√ß√£o, e a fun√ß√£o `onSuccess` que √© chamada quando a muta√ß√£o √© realizada com sucesso. No exemplo acima, a fun√ß√£o `onSuccess` atualiza o cache dos posts com o novo post criado.

Esta abordagem √© muito interessante pois o React Query n√£o realiza nenhuma chamada HTTP GET extra para atualizar os posts ap√≥s a muta√ß√£o. Ele atualiza o cache localmente e exibe o novo post na tela. Isso √© poss√≠vel pois o React Query mant√©m um cache local dos dados e atualiza o cache automaticamente ap√≥s a muta√ß√£o.

<hr/>

## Conclus√£o

Neste artigo, discutimos as op√ß√µes para lidar com fetch e muta√ß√£o de dados em uma aplica√ß√£o React moderna. Vimos abordagens utilizando tanto APIs nativas, quanto tamb√©m bibliotecas dedicadas como o React Query e o SWR, e tamb√©m vimos as solu√ß√µes que o Next.js oferece.

No geral, eu diria que para o server-side, utilizar as solu√ß√µes de fetch de dados nativas do Next.js √© a melhor op√ß√£o. Eles fornecem toda a parte de cache e revalida√ß√£o, al√©m de possuir as Server Actions e m√©todos para a parte de muta√ß√£o de dados.

Eu recomendo fortemente fazer as requisi√ß√µes no lado do servidor sempre que poss√≠vel. Entretanto, para cen√°rios de requisi√ß√µes no client-side, eu recomendo utilizar o React Query ou o SWR, pois al√©m de fornecerem uma API mais simples e intuitiva, o que facilita a legibilidade do c√≥digo para esses cen√°rios, eles tamb√©m possuem as funcionalidades de caching e muta√ß√£o. **Mas enfim**, se fosse pra escolher uma para ser utilizada junto com o Next.js, eu iria de SWR j√° que √© mantida pela pr√≥pria Vercel üòÖ.